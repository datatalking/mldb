#!/usr/bin/env python3.9

max_num_args = 200

# Generate an argument name from a number
def an(i):
    return "__a" + str(i) 

# Generate a protected arg name (one that take the place of a single arg even if it contains commas)
def pan(i):
    return f"__UKL_SINGLE_ARG({an(i)})"

# Generate arg names from first to last
def genargs(first, last):
    return ", ".join([an(n) for n in range(first,last)])

# Generated protected arg names from first to last
def genpargs(first, last):
    return ", ".join([pan(n) for n in range(first,last)])


# Header
print("// autogenerated by ukl_auto_macro_gen.py, do not edit this file")
print("// ukl_auto_macros.h")
print("// Ugly Kernel Language common macro definitions to enable preprocessing of ukl files into target code")
print("// Copyright (c) 2022 Jeremy Barnes.  All rights reserved.")
print("// Part of MLDB; usable under the license of MLDB (Apache 2.0).")
print()

# Include guard
print("#pragma once")
print()

print("// Return all arguments, but taking a single argument slot")
print("#define __UKL_SINGLE_ARG(...) __VA_ARGS__")
print()

# Configuration parameters
print("// Configured maximum number of arguments")
print(f"#define __UKL_MAX_NUM_ARGS {max_num_args}")
print()

# Generate ARG_xxx
argnames = ", ".join([an(n) for n in range(0,max_num_args+1)])
print(f"// Return the {max_num_args+1}-st argument, used to count arguments in __VA_ARGS__")
print(f"#define __UKL_ARG_{max_num_args+1}({argnames},...) {an(max_num_args)}")
print()

# Generate UKL_COUNT_ARGS
print(f"// Return the number of arguments passed as an integer, up to a maximum of UKL_MAX_NUM_ARGS ({max_num_args})")
reversenumbers = ", ".join([str(n-1) for n in range(max_num_args, 0, -1)])
print(f"#define __UKL_COUNT_ARGS(...) __UKL_ARG_{max_num_args+1}(__ukl_dummy, ##__VA_ARGS__, {reversenumbers})")
print()

# Generate UKL_IS_EMPTY and UKL_NOT_EMPTY
print(f"// Return 1 if the argument list is empty and 0 if not, up to a maximum of UKL_MAX_NUM_ARGS ({max_num_args})")
isempty = ", ".join(["0" for n in range(max_num_args-1)]) + ", 1"
print(f"#define __UKL_IS_EMPTY(...) __UKL_ARG_{max_num_args+1}(__ukl_dummy, ##__VA_ARGS__, {isempty})")
print()
notempty = ", ".join(["1" for n in range(max_num_args-1)]) + ", 0"
print(f"// Return 1 if the argument list is empty and 0 if not, up to a maximum of UKL_MAX_NUM_ARGS ({max_num_args})")
print(f"#define __UKL_NOT_EMPTY(...) __UKL_ARG_{max_num_args+1}(__ukl_dummy, ##__VA_ARGS__, {notempty})")
print()

print("// Call the given macro with the given arguments")
print("#define __UKL_CALL(Fn, ...) Fn(__VA_ARGS__)")
print("#define __UKL_CALLA(Fn, ...) Fn(__VA_ARGS__)")
print()

# Generate UKL_CALL
print("// Call the macro given by concatenating Name1 and Name2 with the given args")
print("#define __UKL_CALL2(Name1, Name2, ...) __UKL_CALL(Name1##Name2, __VA_ARGS__)")
print("#define __UKL_CALL2A(Name1, Name2, ...) __UKL_CALLA(Name1##Name2, __VA_ARGS__)")
print()

# Generate UKL_INSERT_COMMAS
print("// Return arguments, inserting commas between non-empty ones (and no comments at the beginning or end)")

print("// Switch to take two arguments, depending upon which is empty, and print them with commas between")
print("#define __UKL_INSERT_COMMAS_SWITCH_00(a1, a2) a1, a2")
print("#define __UKL_INSERT_COMMAS_SWITCH_01(a1, a2) a1")
print("#define __UKL_INSERT_COMMAS_SWITCH_10(a1, a2) a2")
print("#define __UKL_INSERT_COMMAS_SWITCH_11(a1, a2) ")
print()


print("#define __UKL_INSERT_COMMAS(...) __UKL_INSERT_COMMAS_N(__UKL_COUNT_ARGS(__VA_ARGS__), __VA_ARGS__)")
print("#define __UKL_INSERT_COMMAS_N(Count, ...) __UKL_CALL2A(__UKL_INSERT_COMMAS_, Count, __VA_ARGS__)")
print()

# How many levels of commas do we do?  We can have a maximum of 2^num_levels arguments 
# This is necessary because we can't do recursive macro calls in the C preprocessor, so to
# emulate it we need to have multiple macros.
num_levels=5

for level in range(0, num_levels):
    print(f"#define __UKL_CALL_2ARGS_{level}(Fn, a1, a2) Fn(__UKL_SINGLE_ARG(a1), __UKL_SINGLE_ARG(a2))")
    print(f"#define __UKL_CALL3_2ARGS_{level}(Name1, Name2, Name3, a1, a2) __UKL_CALL_2ARGS_{level}(Name1##Name2##Name3, __UKL_SINGLE_ARG(a1), __UKL_SINGLE_ARG(a2))")
    print(f"#define __UKL_INSERT_COMMAS_2_{level}_A(e1, e2, a1, a2) __UKL_CALL3_2ARGS_{level}(__UKL_INSERT_COMMAS_SWITCH_,e1,e2,__UKL_SINGLE_ARG(a1),__UKL_SINGLE_ARG(a2))")
    print(f"#define __UKL_INSERT_COMMAS_2_{level}(a1, a2) __UKL_INSERT_COMMAS_2_{level}_A(__UKL_IS_EMPTY(a1), __UKL_IS_EMPTY(a2), __UKL_SINGLE_ARG(a1), __UKL_SINGLE_ARG(a2))")
    print()

print("#define __UKL_INSERT_COMMAS_0()")
print("#define __UKL_INSERT_COMMAS_1(x) x")
print("#define __UKL_INSERT_COMMAS_2(a1, a2) __UKL_INSERT_COMMAS_2_0(__UKL_SINGLE_ARG(a1), __UKL_SINGLE_ARG(a2))")

# Generate a macro that inserts commas between the n non-empty arguments
# This works by splitting into two parts, and combining them by inserting commas
def gen_insert_commas(lvl, first, last):
    #print(f"first {first} last {last}")
    n = last - first
    if n == 0:
        return ""
    elif n == 1:
        return pan(first)
    elif n == 2:
        return f"__UKL_INSERT_COMMAS_2_{lvl}({pan(first)},{pan(first + 1)})"
    else:
        def ceil_pw2(x):
            return 1<<(x-1).bit_length()
        half = ceil_pw2(int(n / 2))
        mid = first + half
        #left = gen_insert_commas(lvl+1, first, mid)
        #right = gen_insert_commas(lvl+1, mid, last)
        #left = f"__TEST({first}, {mid})"
        #right = f"__TEST({mid+1}, {last})"
        left = f"__UKL_INSERT_COMMAS_{half}({genpargs(first, mid)})"
        right = f"__UKL_INSERT_COMMAS_{n-half}({genpargs(mid, last)})"

        return f"__UKL_INSERT_COMMAS_2_{(n-1).bit_length()-1}({left},{right})"

for i in range(0, 2**num_levels+1):
    if i <= 2:
        continue
    argnames = ", ".join([an(n) for n in range(0,i)])
    print(f"#define __UKL_INSERT_COMMAS_{i}({argnames}) {gen_insert_commas(0, 0, i)}")



# Generate UKL_FOREACH_QUAD
print("// Internal switch to forward to __UKL_FOREACH_QUAD_(numargs) to implement __UKL_FOREACH_QUAD")
print("#define __UKL_FOREACH_QUAD_N(Name, Count, ...) __UKL_CALL2(__UKL_FOREACH_QUAD_, Count, Name, __VA_ARGS__)")
print()

print("// Call the given macro Fn(a1,a2,a3,a4) for each four arguments passed")
print("#define __UKL_FOREACH_QUAD(Fn, ...) __UKL_FOREACH_QUAD_N(Fn, __UKL_COUNT_ARGS(__VA_ARGS__), __VA_ARGS__)")
print()

print("#define __UKL_FOREACH_QUAD_0(Fn)")
for n in range(4,max_num_args,4):
    argnames = ", ".join(["__a" + str(n) for n in range(0,n)])
    calls = ", ".join([f"Fn({an(i)},{an(i+1)},{an(i+2)},{an(i+3)})" for i in range(0,n,4)])
    print(f"#define __UKL_FOREACH_QUAD_{n}(Fn, {argnames}) __UKL_INSERT_COMMAS_{int(n/4)}({calls})")
